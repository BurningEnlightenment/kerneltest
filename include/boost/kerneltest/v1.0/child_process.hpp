/* child_process.hpp
Routines for handling child processes
(C) 2016 Niall Douglas http://www.nedprod.com/
File Created: Marc 2016


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_AFIO_CHILD_PROCESS_H
#define BOOST_AFIO_CHILD_PROCESS_H

#include "../deadline.h"
#include "../native_handle_type.hpp"

#include <map>
#include <vector>

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4251)  // dll interface
#endif

BOOST_AFIO_V2_NAMESPACE_BEGIN

namespace detail
{
  //! Returns the path of the calling process
  BOOST_AFIO_HEADERS_ONLY_FUNC_SPEC stl1z::filesystem::path current_process_path();

  //! Returns the environment of the calling process
  BOOST_AFIO_HEADERS_ONLY_FUNC_SPEC std::map<stl1z::filesystem::path::string_type, stl1z::filesystem::path::string_type> current_process_env();

  /*! \class child_process
  \brief Launches and manages a child process with stdin, stdout and stderr.

  \todo If we ever make more use of child_process, its handles need to be managed by
  handle and use async_pipe_handle or something as the handle implementation to avoid
  deadlocking stdout and stderr.
  */
  class BOOST_AFIO_DECL child_process
  {
    stl1z::filesystem::path _path;
    native_handle_type _processh;
    native_handle_type _readh, _writeh, _errh;
    bool _use_parent_errh;
    std::vector<stl1z::filesystem::path::string_type> _args;
    std::map<stl1z::filesystem::path::string_type, stl1z::filesystem::path::string_type> _env;
    FILE *_stdin, *_stdout, *_stderr;
    std::ostream *_cin;
    std::istream *_cout, *_cerr;

  protected:
    child_process(stl1z::filesystem::path path, bool use_parent_errh, std::vector<stl1z::filesystem::path::string_type> args, std::map<stl1z::filesystem::path::string_type, stl1z::filesystem::path::string_type> env)
        : _path(std::move(path))
        , _use_parent_errh(use_parent_errh)
        , _args(std::move(args))
        , _env(std::move(env))
        , _stdin(nullptr)
        , _stdout(nullptr)
        , _stderr(nullptr)
        , _cin(nullptr)
        , _cout(nullptr)
        , _cerr(nullptr)
    {
    }

    void _initialise_files() const;
    void _deinitialise_files();
    void _initialise_streams() const;
    void _deinitialise_streams();

  public:
    child_process(const child_process &) = delete;
    child_process(child_process &&o) = default;
    child_process &operator=(const child_process &) = delete;
    child_process &operator=(child_process &&) = default;
    ~child_process();

    //! Launches an executable as a child process. No shell is invoked on POSIX.
    static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC result<child_process> launch(stl1z::filesystem::path path, std::vector<stl1z::filesystem::path::string_type> args, std::map<stl1z::filesystem::path::string_type, stl1z::filesystem::path::string_type> env = current_process_env(), bool use_parent_errh = false) noexcept;

    //! Returns the path of the executable
    const stl1z::filesystem::path &path() const noexcept { return _path; }
    //! Returns the args used to launch the executable
    const std::vector<stl1z::filesystem::path::string_type> &arguments() const noexcept { return _args; }
    //! Returns the environment used to launch the executable
    const std::map<stl1z::filesystem::path::string_type, stl1z::filesystem::path::string_type> &environment() const noexcept { return _env; }
    //! Returns the process identifier
    const native_handle_type &process_native_handle() const noexcept { return _processh; }
    //! Returns the read handle
    const native_handle_type &read_native_handle() const noexcept { return _readh; }
    //! Returns the write handle
    const native_handle_type &write_native_handle() const noexcept { return _writeh; }
    //! Returns the error handle
    const native_handle_type &error_native_handle() const noexcept { return _errh; }

    //! Returns the read handle as a FILE *
    FILE *file_in() const
    {
      if(!_stdin)
        _initialise_files();
      return _stdin;
    }
    //! Returns the write handle as a FILE *
    FILE *file_out() const
    {
      if(!_stdout)
        _initialise_files();
      return _stdout;
    }
    //! Returns the error handle as a FILE *
    FILE *file_err() const
    {
      if(!_stderr)
        _initialise_files();
      return _stderr;
    }

    //! Returns the read handle as a ostream &
    std::ostream &cin() const
    {
      if(!_cin)
        _initialise_streams();
      return *_cin;
    }
    //! Returns the write handle as a istream &
    std::istream &cout() const
    {
      if(!_cout)
        _initialise_streams();
      return *_cout;
    }
    //! Returns the error handle as a istream &
    std::istream &cerr() const
    {
      if(!_cerr)
        _initialise_streams();
      return *_cerr;
    }

    //! True if child process is currently running
    bool is_running() const noexcept;

    //! Waits for a child process to exit until deadline /em d
    result<intptr_t> wait_until(deadline d) noexcept;
    //! \overload
    result<intptr_t> wait() noexcept { return wait_until(deadline()); }
  };
}

BOOST_AFIO_V2_NAMESPACE_END

#if BOOST_AFIO_HEADERS_ONLY == 1 && !defined(DOXYGEN_SHOULD_SKIP_THIS)
#define BOOST_AFIO_INCLUDED_BY_HEADER 1
#include "impl/child_process.ipp"
#undef BOOST_AFIO_INCLUDED_BY_HEADER
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif
